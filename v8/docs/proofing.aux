\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\@writefile{toc}{\contentsline {section}{\numberline {1}Introduction and Problem Formulation}{2}{section.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {1.1}Notation and Definitions}{2}{subsection.1.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {1.2}HNSW Baseline Parameters}{2}{subsection.1.2}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {2}ZGQ Theoretical Framework}{2}{section.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}Zone-Ordered Graph Construction}{2}{subsection.2.1}\protected@file@percent }
\newlabel{thm:local-connectivity}{{2.3}{2}{Improved Local Connectivity}{theorem.2.3}{}}
\newlabel{thm:local-connectivity@cref}{{[theorem][3][2]2.3}{[1][2][]2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}Search Complexity Analysis}{3}{subsection.2.2}\protected@file@percent }
\newlabel{thm:path-length}{{2.4}{3}{Search Path Length Reduction}{theorem.2.4}{}}
\newlabel{thm:path-length@cref}{{[theorem][4][2]2.4}{[1][3][]3}}
\@writefile{toc}{\contentsline {section}{\numberline {3}Recall-Efficiency Trade-off Analysis}{4}{section.3}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1}Iso-Recall Comparison Framework}{4}{subsection.3.1}\protected@file@percent }
\newlabel{thm:efficiency}{{3.2}{4}{ZGQ Efficiency Advantage}{theorem.3.2}{}}
\newlabel{thm:efficiency@cref}{{[theorem][2][3]3.2}{[1][4][]4}}
\@writefile{toc}{\contentsline {section}{\numberline {4}Empirical Validation}{5}{section.4}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1}Benchmark Configuration}{5}{subsection.4.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2}Algorithm Configurations}{5}{subsection.4.2}\protected@file@percent }
\@writefile{lot}{\contentsline {table}{\numberline {1}{\ignorespaces Algorithm Parameter Comparison}}{5}{table.1}\protected@file@percent }
\newlabel{tab:params}{{1}{5}{Algorithm Parameter Comparison}{table.1}{}}
\newlabel{tab:params@cref}{{[table][1][]1}{[1][5][]5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.3}Benchmark Results}{5}{subsection.4.3}\protected@file@percent }
\newlabel{eq:recall-bound}{{1}{5}{Empirical Performance Bounds}{equation.4.1}{}}
\newlabel{eq:recall-bound@cref}{{[equation][1][]1}{[1][5][]5}}
\newlabel{eq:qps-bound}{{2}{5}{Empirical Performance Bounds}{equation.4.2}{}}
\newlabel{eq:qps-bound@cref}{{[equation][2][]2}{[1][5][]5}}
\newlabel{eq:latency-bound}{{3}{5}{Empirical Performance Bounds}{equation.4.3}{}}
\newlabel{eq:latency-bound@cref}{{[equation][3][]3}{[1][5][]5}}
\@writefile{lot}{\contentsline {table}{\numberline {2}{\ignorespaces 100K Scale Benchmark Results (Draft Findings)}}{5}{table.2}\protected@file@percent }
\newlabel{tab:results}{{2}{5}{100K Scale Benchmark Results (Draft Findings)}{table.2}{}}
\newlabel{tab:results@cref}{{[table][2][]2}{[1][5][]5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.4}Key Comparisons}{6}{subsection.4.4}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {5}Theoretical vs Empirical Correlation}{6}{section.5}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {6}Empirical Results and Visualizations}{6}{section.6}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {7}Conclusions}{6}{section.7}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {7.1}Summary of Contributions}{6}{subsection.7.1}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces Performance Summary Table showing ZGQ v8 wins on 3 out of 4 metrics compared to HNSW. ZGQ achieves higher recall, throughput (QPS), and lower latency, with the trade-off of longer build time due to Python implementation versus C++ optimized HNSW.}}{7}{figure.1}\protected@file@percent }
\newlabel{fig:summary}{{1}{7}{Performance Summary Table showing ZGQ v8 wins on 3 out of 4 metrics compared to HNSW. ZGQ achieves higher recall, throughput (QPS), and lower latency, with the trade-off of longer build time due to Python implementation versus C++ optimized HNSW}{figure.1}{}}
\newlabel{fig:summary@cref}{{[figure][1][]1}{[1][6][]7}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces Recall vs. Throughput (QPS) comparison showing the Pareto frontier. ZGQ v8 achieves superior recall-throughput trade-off, demonstrating that at equivalent recall levels, ZGQ delivers significantly higher query throughput than HNSW.}}{7}{figure.2}\protected@file@percent }
\newlabel{fig:pareto}{{2}{7}{Recall vs. Throughput (QPS) comparison showing the Pareto frontier. ZGQ v8 achieves superior recall-throughput trade-off, demonstrating that at equivalent recall levels, ZGQ delivers significantly higher query throughput than HNSW}{figure.2}{}}
\newlabel{fig:pareto@cref}{{[figure][2][]2}{[1][6][]7}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces Query latency comparison at different search depths (ef\_search). ZGQ v8 demonstrates consistently lower query latency across all configurations, with the most significant advantage appearing at the iso-recall point (ZGQ ef=128 vs HNSW ef=200, showing 22\% latency reduction).}}{8}{figure.3}\protected@file@percent }
\newlabel{fig:latency}{{3}{8}{Query latency comparison at different search depths (ef\_search). ZGQ v8 demonstrates consistently lower query latency across all configurations, with the most significant advantage appearing at the iso-recall point (ZGQ ef=128 vs HNSW ef=200, showing 22\% latency reduction)}{figure.3}{}}
\newlabel{fig:latency@cref}{{[figure][3][]3}{[1][6][]8}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces Multi-dimensional performance radar chart comparing ZGQ v8 and HNSW across all key metrics. The chart visualizes ZGQ's advantages in recall, throughput, and latency, while also showing HNSW's advantage in build time. The overlapping area demonstrates where each algorithm excels.}}{9}{figure.4}\protected@file@percent }
\newlabel{fig:radar}{{4}{9}{Multi-dimensional performance radar chart comparing ZGQ v8 and HNSW across all key metrics. The chart visualizes ZGQ's advantages in recall, throughput, and latency, while also showing HNSW's advantage in build time. The overlapping area demonstrates where each algorithm excels}{figure.4}{}}
\newlabel{fig:radar@cref}{{[figure][4][]4}{[1][6][]9}}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces Throughput (QPS) comparison across different ef\_search configurations. Bar chart clearly demonstrates ZGQ's 28\% throughput advantage at the iso-recall configuration (ef=128 for ZGQ vs ef=200 for HNSW).}}{10}{figure.5}\protected@file@percent }
\newlabel{fig:throughput}{{5}{10}{Throughput (QPS) comparison across different ef\_search configurations. Bar chart clearly demonstrates ZGQ's 28\% throughput advantage at the iso-recall configuration (ef=128 for ZGQ vs ef=200 for HNSW)}{figure.5}{}}
\newlabel{fig:throughput@cref}{{[figure][5][]5}{[1][6][]10}}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces Pareto frontier analysis showing the recall-efficiency trade-off space. Points closer to the top-right corner represent superior configurations. ZGQ's curve dominates HNSW's curve in the high-recall region, confirming the theoretical efficiency advantage proven in Theorem~\ref {thm:efficiency}.}}{11}{figure.6}\protected@file@percent }
\newlabel{fig:pareto_frontier}{{6}{11}{Pareto frontier analysis showing the recall-efficiency trade-off space. Points closer to the top-right corner represent superior configurations. ZGQ's curve dominates HNSW's curve in the high-recall region, confirming the theoretical efficiency advantage proven in Theorem~\ref {thm:efficiency}}{figure.6}{}}
\newlabel{fig:pareto_frontier@cref}{{[figure][6][]6}{[1][6][]11}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces Index build time comparison. HNSW (C++ implementation) completes index construction in 2.14 seconds, while ZGQ v8 (Python implementation) requires 3.59 seconds. This 68\% longer build time is the primary trade-off for ZGQ's superior query performance.}}{12}{figure.7}\protected@file@percent }
\newlabel{fig:buildtime}{{7}{12}{Index build time comparison. HNSW (C++ implementation) completes index construction in 2.14 seconds, while ZGQ v8 (Python implementation) requires 3.59 seconds. This 68\% longer build time is the primary trade-off for ZGQ's superior query performance}{figure.7}{}}
\newlabel{fig:buildtime@cref}{{[figure][7][]7}{[1][6][]12}}
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces Scaling analysis showing performance trends across different dataset sizes and configurations. The analysis demonstrates how ZGQ's advantages become more pronounced as the dataset size increases, validating the theoretical prediction from Theorem~\ref {thm:path-length}.}}{12}{figure.8}\protected@file@percent }
\newlabel{fig:scaling}{{8}{12}{Scaling analysis showing performance trends across different dataset sizes and configurations. The analysis demonstrates how ZGQ's advantages become more pronounced as the dataset size increases, validating the theoretical prediction from Theorem~\ref {thm:path-length}}{figure.8}{}}
\newlabel{fig:scaling@cref}{{[figure][8][]8}{[1][6][]12}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.2}Key Findings}{13}{subsection.7.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {7.3}Practical Implications}{13}{subsection.7.3}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {A}Derivation Details}{13}{appendix.A}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {A.1}Zone Density Factor $\alpha $}{13}{subsection.A.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {A.2}Zone-Guidance Efficiency Factor $\beta $}{13}{subsection.A.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {A.3}QPS Calculation}{13}{subsection.A.3}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {B}Reproducibility}{14}{appendix.B}\protected@file@percent }
\gdef \@abspage@last{14}
